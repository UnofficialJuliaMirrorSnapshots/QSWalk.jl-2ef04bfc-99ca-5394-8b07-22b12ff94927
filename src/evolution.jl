export
  evolve_operator,
  evolve

"""
    evolve_operator(evo_gen, time)

Return an exponent of `time`×`evo_gen`. This function is useful in the case of
multiple initial states and fixed `evo_gen` and `time`, as it is faster to
compute the exponent once and use it for evolving on different initial states.

*Note:* Parameter `evo_gen` must be of type `Matrix`. For type `SparseMatrixCSC`
case different numerical approach is used. See function ```epmv``` in package
```Expokit```.

# Examples

```jldoctest; setup = :(using QSWalk)
julia> H, L = [0 1; 1 0], [[0 1; 0 0], [0 0; 1 0]]
([0 1; 1 0], Array{Int64,2}[[0 1; 0 0], [0 0; 1 0]])

julia> evolve_operator(evolve_generator(H, L), 4.0)
4×4 Array{Complex{Float64},2}:
 0.499815+0.0im                0.0+0.00127256im  …  0.500185+0.0im
      0.0+0.00127256im  0.00960957+0.0im                 0.0-0.00127256im
      0.0-0.00127256im  0.00870607+0.0im                 0.0+0.00127256im
 0.500185+0.0im                0.0-0.00127256im     0.499815+0.0im
```
"""
function evolve_operator(evo_gen::AbstractMatrix{<:Number}, time::Real)
  @argumentcheck time>= 0 "Time has to be nonnegative"
  @argumentcheck size(evo_gen, 1) == size(evo_gen, 2) "Argument evo_gen has to be a square matrix"

  exp(time*evo_gen)
end

"""

    evolve(evogen, state, time)
    evolve(evogen, state, tpoints)
    evolve(evosuper, state)

Simulate the GKSL master equation according to the equation

``|result⟩⟩ = exp(time*evogen)|state⟩⟩``

where ``|⋅⟩⟩`` denotes the vectorization.

*Note:* The function returns unvectorized `result`.

The evolution can be calculated using three different approaches.

In the simplest case the function accepts matrix `evogen` specifying the
generator of the evolution, `state` describing the starting point of the
evolution, and `time` specifying the time of the evolution.

*Note:* If `evogen` is of type `Matrix`, the exponent is calculated using
`exp` function. If `evogen` is of type `SparseMatrixCSC`, `expmv` from
`Expokit.jl` is used.

Alternatively, a list of point of time (`tpoints`) can be given. Points of time
needs to be non-negative (you cannot go back in time). In this case a list of
resulting states is returned.

*Note:* It is up to the user to provide `evogen` and `state` fulfilling
the appropriate conditions. For the procedure to work correctly `evogen` should
be generated by `evolve_generator` function and `state` should be a proper
density matrix.

The third approach can be used if the superoperator is known. In this case
argument `evosuper` can be specified. This argument can be generated by
`evolve_operator` function. This is useful to simulate a fixed model of
evolution in the case of multiple initial states and the same time point.

# Examples

```jldoctest; setup = :(using QSWalk)
julia> H, L = [0 1; 1 0], [[0 1; 0 0], [0 0; 1 0]]
([0 1; 1 0], Array{Int64,2}[[0 1; 0 0], [0 0; 1 0]])

julia> Matrix(evolve(evolve_generator(H, L), proj(1, 2), 4.))
2×2 Array{Complex{Float64},2}:
 0.499815+0.0im              0.0+0.00127256im
      0.0-0.00127256im  0.500185+0.0im

julia> Matrix.(evolve(evolve_generator(H, L), proj(1, 2), [1., 2., 3., 4.]))
4-element Array{Array{Complex{Float64},2},1}:
 [0.433203+0.0im 0.0+0.107605im; 0.0-0.107605im 0.566797+0.0im]
 [0.485766+0.0im 0.0-0.0171718im; 0.0+0.0171718im 0.514234+0.0im]
 [0.505597+0.0im 0.0-0.00261701im; 0.0+0.00261701im 0.494403+0.0im]
 [0.499815+0.0im 0.0+0.00127256im; 0.0-0.00127256im 0.500185+0.0im]

julia> ev_op = evolve_operator(evolve_generator(H, L), 4.)
4×4 Array{Complex{Float64},2}:
 0.499815+0.0im                0.0+0.00127256im  …  0.500185+0.0im
      0.0+0.00127256im  0.00960957+0.0im                 0.0-0.00127256im
      0.0-0.00127256im  0.00870607+0.0im                 0.0+0.00127256im
 0.500185+0.0im                0.0-0.00127256im     0.499815+0.0im

julia> Matrix(evolve(ev_op, proj(1, 2)))
2×2 Array{Complex{Float64},2}:
 0.499815+0.0im              0.0+0.00127256im
      0.0-0.00127256im  0.500185+0.0im
```
"""
function evolve(exp_evolve_generator::AbstractMatrix{<:Number},
                initial_state::AbstractMatrix{<:Number})
  @argumentcheck size(exp_evolve_generator, 1) == size(exp_evolve_generator, 2) "Argument exp_evolve_generator should be square"
  @argumentcheck size(initial_state, 1) == size(initial_state, 2) "Initial_state should be a square matrix"
  @assert size(exp_evolve_generator, 1) == size(initial_state, 1)^2 "The initial state size should be square root of exp_evolve_generator size"

  unres(exp_evolve_generator*res(initial_state))
end,

function evolve(evolve_generator::AbstractMatrix{<:Number},
                initial_state::AbstractMatrix{<:Number},
                timepoint::Real)
  @argumentcheck size(evolve_generator, 1) == size(evolve_generator, 2) "Argument evolve_generator should be square"
  @argumentcheck size(initial_state, 1) == size(initial_state, 2) "Initial_state should be a square matrix"
  @assert size(evolve_generator, 1) == size(initial_state, 1)^2 "The initial state size should be square root of evolve_generator size"
  @argumentcheck timepoint>= 0 "Time needs to be nonnegative"

  unres(exp(timepoint*evolve_generator)*res(initial_state))
end,

function evolve(evolve_generator::SparseMatrixCSC{<:Number},
                initial_state::AbstractMatrix{<:Number},
                timepoint::Real)
  @argumentcheck size(evolve_generator, 1) == size(evolve_generator, 2) "Argument evolve_generator should be a square matrix"
  @argumentcheck size(initial_state, 1) == size(initial_state, 2) "Argument initial_state should be a square matrix"
  @assert size(evolve_generator, 1) == size(initial_state, 1)^2 "The initial state size should be square root of evolve_generator size"
  @argumentcheck timepoint>= 0 "Time needs to be nonnegative"

  unres(expmv(timepoint, evolve_generator, Vector(res(initial_state))))
end,

function evolve(evolve_generator::AbstractMatrix{<:Number},
                initial_state::AbstractMatrix{<:Number},
                timepoints::AbstractVector{<:Real})
  @argumentcheck size(evolve_generator, 1) == size(evolve_generator, 2) "evolve_generator should be a square matrix"
  @argumentcheck size(initial_state, 1) == size(initial_state, 2) "Argument initial_state should be a square matrix"
  @assert size(evolve_generator, 1) == size(initial_state, 1)^2 "The initial state size should be square root of evolve_generator size"
  @argumentcheck all(timepoints.>= 0) "All time points need to be nonnegative"

  [evolve(evolve_generator, initial_state, t) for t = timepoints]
end
